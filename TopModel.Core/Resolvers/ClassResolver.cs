using TopModel.Core.FileModel;

namespace TopModel.Core.Resolvers;

internal class ClassResolver(ModelFile modelFile, IDictionary<string, Class> referencedClasses)
{
    /// <summary>
    /// Effectue les vérifications de cohérence sur le résultat de la résolution des classes.
    /// </summary>
    /// <returns>Erreurs.</returns>
    public IEnumerable<ModelError> CheckResult()
    {
        foreach (var classe in modelFile.Classes)
        {
            foreach (var property in classe.ExtendedProperties.Where((e, i) => classe.ExtendedProperties.Where((p, j) => p.Name == e.Name && j < i).Any()))
            {
                yield return new ModelError(modelFile, $"Le nom '{property.Name}' est déjà utilisé.", property.Decorator is not null ? classe.DecoratorReferences.FirstOrDefault(dr => dr.ReferenceName == property.Decorator.Name) : property.GetLocation())
                {
                    IsError = true,
                    ModelErrorType = ModelErrorType.TMD0003
                };
            }

            foreach (var property in classe.Properties.OfType<AssociationProperty>().Where(p => (p.Association == classe || p.Association == classe.Extends) && string.IsNullOrEmpty(p.Role)))
            {
                yield return new ModelError(modelFile, $"Cette association sur la classe '{classe}' doit définir un rôle.", property.Decorator is not null ? classe.DecoratorReferences.FirstOrDefault(dr => dr.ReferenceName == property.Decorator.Name) : property.GetLocation())
                {
                    IsError = true,
                    ModelErrorType = ModelErrorType.TMD1029
                };
            }
        }

        foreach (var classe in modelFile.Classes.Where(c => c.Values.Count > 0 && (c.IsPersistent || c.UniqueKeys.Count > 0)))
        {
            var uks = new List<IEnumerable<IFieldProperty>>();
            uks.AddRange(classe.UniqueKeys);
            if (classe.IsPersistent)
            {
                uks.Add(classe.PrimaryKey.Any() ? classe.PrimaryKey : (classe.Extends?.PrimaryKey ?? []));
            }

            foreach (var uk in uks)
            {
                if (!classe.Values.All(value => uk.All(p => value.Value.ContainsKey(p))))
                {
                    continue;
                }

                var ukValues = classe.Values.Select(value => string.Concat(uk.Select(p => value.Value[p]))).ToList();
                for (int i = 0; i < classe.Values.Count; i++)
                {
                    var ukValue = string.Concat(uk.Select(p => classe.Values[i].Value[p]));
                    if (ukValues.IndexOf(ukValue) < i)
                    {
                        var duplicateValue = classe.Values[i];
                        yield return new ModelError(duplicateValue, $"La valeur viole la contrainte d'unicité [{string.Join(", ", uk.Select(u => u.Name))}]", duplicateValue.Reference) { IsError = true, ModelErrorType = ModelErrorType.TMD1013 };
                    }
                }
            }
        }
    }

    /// <summary>
    /// Vérifie `reference` et `enum`.
    /// </summary>
    /// <returns>Erreurs.</returns>
    public IEnumerable<ModelError> ResolveEnums()
    {
        foreach (var classe in modelFile.Classes.Where(c => c.Reference && c.ReferenceKey == null))
        {
            yield return new ModelError(classe, $"La classe '{classe}' doit avoir au moins une propriété non composée et au plus une clé primaire pour être définie comme `reference`.") { ModelErrorType = ModelErrorType.TMD0001 };
        }

        foreach (var classe in modelFile.Classes)
        {
            if (classe.EnumOverride != null)
            {
                if (classe.EnumOverride == "true" && (classe.Values.Count == 0 || classe.ReferenceKey == null))
                {
                    yield return new ModelError(classe, $"La classe '{classe}' doit avoir au moins une propriété non composée, au plus une clé primaire et au moins une `value` pour être définie comme `enum`.", classe.EnumOverride.Location) { ModelErrorType = ModelErrorType.TMD0006 };
                }
                else
                {
                    classe.Enum = classe.EnumOverride == "true";
                }
            }
            else
            {
                classe.Enum = classe.Values.Count > 0 && classe.ReferenceKey != null && !(classe.ReferenceKey.Domain?.AutoGeneratedValue ?? false);
            }

            if (classe.Extends != null && classe.Enum != classe.Extends.Enum)
            {
                yield return new ModelError(classe, $"La classe '{classe}' et sa classe parente '{classe.Extends}' doivent toutes les deux être des `enum`.") { ModelErrorType = ModelErrorType.TMD1031 };
            }
        }
    }

    /// <summary>
    /// Résout les "extends".
    /// </summary>
    /// <returns>Erreurs.</returns>
    public IEnumerable<ModelError> ResolveExtends()
    {
        foreach (var classe in modelFile.Classes.Where(c => c.ExtendsReference != null))
        {
            if (classe.Abstract)
            {
                yield return new ModelError(classe, $"Impossible de définir un 'extends' sur la classe '{classe}' abstraite.", classe.ExtendsReference!) { ModelErrorType = ModelErrorType.TMD1026 };
                continue;
            }

            if (!referencedClasses.TryGetValue(classe.ExtendsReference!.ReferenceName, out var extends))
            {
                yield return new ModelError(classe, "La classe '{0}' est introuvable dans le fichier ou l'une de ses dépendances.", classe.ExtendsReference!) { ModelErrorType = ModelErrorType.TMD1002 };
                continue;
            }

            if (extends.Abstract)
            {
                yield return new ModelError(classe, $"Impossible de définir la classe '{extends}' abstraite comme 'extends' sur la classe '{classe}'.", classe.ExtendsReference!) { ModelErrorType = ModelErrorType.TMD1026 };
                continue;
            }

            if (extends.PrimaryKey.Count() > 1)
            {
                yield return new ModelError(classe, $"Impossible de définir la classe '{extends}' comme 'extends' sur la classe '{classe}' car elle a une clé primaire composite.", classe.ExtendsReference!) { ModelErrorType = ModelErrorType.TMD1030 };
                continue;
            }

            classe.Extends = extends;
        }
    }

    /// <summary>
    /// Résout les propriétés spéciales de classe.
    /// </summary>
    /// <returns>Erreurs.</returns>
    public IEnumerable<ModelError> ResolveSpecialProperties()
    {
        foreach (var classe in modelFile.Classes)
        {
            if (classe.DefaultPropertyReference != null)
            {
                classe.DefaultProperty = classe.ExtendedProperties.OfType<IFieldProperty>().FirstOrDefault(fp => fp.Name == classe.DefaultPropertyReference.ReferenceName);
                if (classe.DefaultProperty == null)
                {
                    yield return new ModelError(classe, $"La propriété '{classe.DefaultPropertyReference.ReferenceName}' n'existe pas sur la classe '{classe}'.", classe.DefaultPropertyReference) { ModelErrorType = ModelErrorType.TMD1011 };
                }
            }
            else
            {
                // Si la classe a une propriété "Label" ou "Libelle", alors on la considère par défaut (sic) comme propriété par défaut.
                classe.DefaultProperty = classe.ExtendedProperties.OfType<IFieldProperty>().FirstOrDefault(fp => fp.NamePascal == "Label" || fp.NamePascal == "Libelle");
            }

            if (classe.OrderPropertyReference != null)
            {
                classe.OrderProperty = classe.ExtendedProperties.OfType<IFieldProperty>().FirstOrDefault(fp => fp.Name == classe.OrderPropertyReference.ReferenceName);
                if (classe.OrderProperty == null)
                {
                    yield return new ModelError(classe, $"La propriété '{classe.OrderPropertyReference.ReferenceName}' n'existe pas sur la classe '{classe}'.", classe.OrderPropertyReference) { ModelErrorType = ModelErrorType.TMD1011 };
                }
            }
            else
            {
                // Si la classe a une propriété "Order" ou "Ordre", alors on la considère par défaut comme propriété d'ordre.
                classe.OrderProperty = classe.ExtendedProperties.OfType<IFieldProperty>().FirstOrDefault(fp => fp.NamePascal == "Order" || fp.NamePascal == "Ordre");
            }

            if (classe.FlagPropertyReference != null)
            {
                classe.FlagProperty = classe.ExtendedProperties.OfType<IFieldProperty>().FirstOrDefault(fp => fp.Name == classe.FlagPropertyReference.ReferenceName);
                if (classe.FlagProperty == null)
                {
                    yield return new ModelError(classe, $"La propriété '{classe.FlagPropertyReference.ReferenceName}' n'existe pas sur la classe '{classe}'.", classe.FlagPropertyReference) { ModelErrorType = ModelErrorType.TMD1011 };
                }
            }
            else
            {
                // Si la classe a une propriété "Flag", alors on la considère par défaut comme propriété de flag.
                classe.FlagProperty = classe.ExtendedProperties.OfType<IFieldProperty>().FirstOrDefault(fp => fp.NamePascal == "Flag");
            }
        }
    }

    /// <summary>
    /// Résout les traductions.
    /// </summary>
    /// <param name="translationStore">Store de traduction.</param>
    /// <param name="defaultLang">Langue par défaut.</param>
    public void ResolveTranslations(TranslationStore translationStore, string defaultLang)
    {
        foreach (var classe in modelFile.Classes)
        {
            foreach (var p in classe.Properties.OfType<IFieldProperty>().Where(p => p.Label != null))
            {
                translationStore.Translations[defaultLang][p.ResourceKey] = p.Label!;
            }

            if (classe.DefaultProperty != null)
            {
                foreach (var r in classe.Values)
                {
                    if (r.Value.TryGetValue(classe.DefaultProperty, out var labelProperty))
                    {
                        translationStore.Translations[defaultLang][r.ResourceKey] = labelProperty;
                    }
                }
            }
        }
    }

    /// <summary>
    /// Résout les clés d'unicité.
    /// </summary>
    /// <returns>Erreurs.</returns>
    public IEnumerable<ModelError> ResolveUniqueKeys()
    {
        foreach (var classe in modelFile.Classes.Where(c => c.UniqueKeyReferences.Count > 0))
        {
            classe.UniqueKeys.Clear();

            foreach (var ukRef in classe.UniqueKeyReferences)
            {
                var uk = new List<IFieldProperty>();
                classe.UniqueKeys.Add(uk);

                foreach (var ukPropRef in ukRef)
                {
                    var property = classe.Properties.OfType<IFieldProperty>().FirstOrDefault(p => p.Name == ukPropRef.ReferenceName);

                    if (property == null)
                    {
                        yield return new ModelError(classe, $"La propriété '{ukPropRef.ReferenceName}' n'existe pas sur la classe '{classe}'.", ukPropRef) { ModelErrorType = ModelErrorType.TMD1011 };
                    }
                    else
                    {
                        uk.Add(property);
                    }
                }
            }
        }
    }

    /// <summary>
    /// Résout les valeurs de classes.
    /// </summary>
    /// <returns>Erreurs.</returns>
    public IEnumerable<ModelError> ResolveValues()
    {
        foreach (var classe in modelFile.Classes.Where(c => c.ValueReferences.Count > 0))
        {
            classe.Values.Clear();

            foreach (var valueRef in classe.ValueReferences)
            {
                var classValue = new ClassValue { Name = valueRef.Key.ReferenceName, Class = classe, Reference = valueRef.Key };
                classe.Values.Add(classValue);

                foreach (var value in valueRef.Value)
                {
                    var property = classe.ExtendedProperties.OfType<IFieldProperty>().FirstOrDefault(p => p.Name == value.Key.ReferenceName);

                    if (property == null)
                    {
                        yield return new ModelError(classe, $"La propriété '{value.Key.ReferenceName}' n'existe pas sur la classe '{classe}'.", value.Key) { ModelErrorType = ModelErrorType.TMD1011 };
                    }
                    else
                    {
                        classValue.Value.Add(property, value.Value);
                    }
                }

                var missingRequiredProperties = classe.ExtendedProperties.OfType<IFieldProperty>()
                    .Where(p =>
                        p.Required
                        && (!(p.Domain?.AutoGeneratedValue ?? false) || p is AssociationProperty or AliasProperty { Property: AssociationProperty })
                        && !valueRef.Value.Any(v => v.Key.ReferenceName == p.Name));

                if (missingRequiredProperties.Any())
                {
                    yield return new ModelError(classe, $"La valeur '{valueRef.Key.ReferenceName}' n'initialise pas les propriétés obligatoires suivantes : {string.Join(", ", missingRequiredProperties.Select(p => p.Name))}.", valueRef.Key) { ModelErrorType = ModelErrorType.TMD1012 };
                }
            }
        }
    }
}
